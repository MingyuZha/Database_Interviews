# 数据库基础知识

# 目录

* [Functional Dependency (函数依赖)](#functional-dependency-函数依赖)

* [Key (键)](#key-键)

   * [超键 (Superkey)](#超键-superkey)

   * [阿姆斯壮定则 (<em>Armstrong's Axioms</em>)](#阿姆斯壮定则-armstrongs-axioms)

* [Normal Forms (范式)](#normal-forms-范式)
   * [First Normal Form (第一范式)](#first-normal-form-第一范式)
   * [Second Normal Form (第二范式)](#second-normal-form-第二范式)
   * [Third Normal Form (第三范式)](#third-normal-form-第三范式)
   * [BCNF范式](#bcnf范式)
* [事务(Transaction)](#事务-transaction)

## Functional Dependency (函数依赖)

如果两条记录中属性A1, A2, … , An一致，那么这两条记录的属性B1, B2, … , Bn也一定一致，这就是功能相依性，用符号表示为：![eq](https://latex.codecogs.com/gif.latex?A_1%2C%20A_2%2C%20%5Cdots%2C%20A_n%5Crightarrow%20B_1%2C%20B_2%2C%20%5Cdots%2C%20B_n)

如果已知关系表R(A, B, C)中存在功能相依性：A —> B，那么对于表中所有的记录，只要确定了A属性的值，B属性的值也随之确定了。

> 给定一张表的某个实例(instance)，我们无法推断出这张表是否具有某些功能相依性，因为功能相依性是一个**全局**属性，我们无法通过表中的一部分数据来做推断。但是我们可以通过表中的一部分数据来判断表是否**不具备**某些功能相依性。

## Key (键)

数据库中的键代表了一些列属性的集合，这个属性集合能够**唯一确定**其他的属性。

一个关系型数据库可以有多个键。

### 超键 (Superkey)

超键的定义是：一个包含了**键(key)**的属性集合，它可能包含冗余属性。

如何判断某个给定的属性集合是否为超键？

答：可以通过计算该集合的**Closure**，如果**Closure**中包含了数据库中所有的属性，那么给定的属性集合就是超键。

### 阿姆斯壮定则 (*Armstrong's Axioms*)

* Reflexivity Rule：A1, A2, …. , An —> {A1, A2, … , An}的一个子集

* Augmentation Rule：如果A1A2…An —> B1B2…Bm，那么A1A2…AnC1C2…Ck —> B1B2…BmC1C2…Ck
* Transitivity rule：如果A1A2…An —> B1B2…Bm并且B1B2…Bm —> C1C2…Ck，那么A1A2…An —> C1C2…Ck

## Normal Forms (范式)

### First Normal Form (第一范式)

数据库表中的每个属性都不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。下图所示的数据表就不满足第一范式：

![img](https://pic4.zhimg.com/80/24afd11455ac34a280fa83e4e8d75ccc_hd.jpg)

> 1NF是所有关系型数据库的最基本要求

如果将上表改为如下形式，就满足了1NF。

![img](https://pic3.zhimg.com/80/6b735fb9503b0930e741faa474fed28e_hd.jpg)

### Second Normal Form (第二范式)

但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，修改异常的问题，例如对于下表的设计：

![img](https://pic4.zhimg.com/80/5b16f655b57a957bfa340d0a996a0eea_hd.jpg)

1. 每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——**数据冗余过大**
2. 假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——**插入异常**
3. 假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——**删除异常**
4. 假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——**修改异常**。

正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“**规范化**”。

> 第二范式(2NF)相比于第一范式(1NF)做的改进在于：消除了**非主属性**对于Minimal key(中文里好像叫"**码**"？)的**部分函数依赖**。

#### 函数依赖

函数依赖的概念已经在前面有所提及，这边就再扩展一下关于函数依赖的具体分类，它可以被分为两大类：完全函数依赖和部分函数依赖

##### 完全函数依赖

在一张表中，若X -> Y，且对于X的任何一个真子集X'，X' -> Y不成立，那么我们称Y对于X完全函数依赖。

##### 部分函数依赖

加入Y函数依赖于X，但同时Y并不完全函数依赖于X，那么我们就称Y部分函数依赖于X。简单点理解就是，如果Y完全依赖于X'，那么X就是包含了X'的属性以及其余一些冗余属性的属性集合。

##### 传递函数依赖

假设Z函数依赖与Y，且Y函数依赖与X，那么我们就称Z传递函数依赖于X

### 如何判断表是否符合第二范式？

判断的依据实际上就是看数据表中**是否存在非主属性对于码的部分函数依赖**。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。判断的方法是：

1. 找出数据表中所有的**minimal key(码)**
2. 根据第一步得到的码，找出所有的**主属性**
3. 数据表中，除去所有主属性，剩下的就是**非主属性**了
4. 查看是否存在非主属性对码的**部分函数依赖**

例如，对于上文贴出的学生成绩表，我们可以首先得到该表的码是**(学号，课名)**。因此，主属性有两个：**学号** 与 **课名**，非主属性有四个：**姓名**、**系名**、**系主任**、**分数**。

1. 对于**（学号，课名） → 姓名**，有 **学号 → 姓名**，存在非主属性 **姓名** 对码**（学号，课名）**的部分函数依赖。
2. 对于**（学号，课名） → 系名**，有 **学号 → 系名**，存在非主属性 **系名** 对码**（学号，课名）**的部分函数依赖。
3. 对于**（学号，课名） → 系主任**，有 **学号 → 系主任**，存在非主属性 **系主任** 对码**（学号，课名）**的部分函数依赖。

所以表3存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。

为了让表3符合2NF的要求，我们必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”**模式分解**“。模式分解的方法不是唯一的，以下是其中一种方法：

1. 选课（学号，课名，分数）
2. 学生（学号，姓名，系名，系主任）

![img](https://pic4.zhimg.com/80/44af74509a4e21372ed372be8560539d_hd.jpg)

这样一来，对于**选课**表，其码是**（学号，课名）**，主属性是**学号**和**课名**，非主属性是**分数**，**学号**确定，并不能唯一确定**分数**，**课名**确定，也不能唯一确定**分数**，所以不存在非主属性**分数**对于码 **（学号，课名）**的部分函数依赖，所以此表符合2NF的要求。

对于**学生**表，其码是**学号，**主属性是**学号**，非主属性是**姓名、系名**和**系主任**，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。

1. 李小明转系到法律系
   只需要修改一次李小明对应的系的值即可。——**有改进**
2. 数据冗余是否减少了？
   学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——**有改进**
3. 删除某个系中所有的学生记录
   该系的信息仍然全部丢失。——**无改进**
4. 插入一个尚无学生的新系的信息。
   因为学生表的码是学号，不能为空，所以此操作不被允许。——**无改进**

所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性**系主任**对于码**学号**的传递函数依赖。为了能进一步解决这些问题，我们还需要将符合2NF要求的数据表改进为符合3NF的要求。

### Third Normal Form (第三范式)

**第三范式（3NF）** **3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖**。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。

对于满足第二范式的表格拆分结果，我们可以检查一下这两张表是否满足第三范式。

对于**选课**表，主码为（学号，课名），主属性为**学号**和**课名，**非主属性只有一个，为分数，不可能存在传递函数依赖，所以**选课**表的设计，符合3NF的要求。

对于**学生**表，主码为**学号**，主属性为**学号**，非主属性为**姓名**、**系名**和**系主任**。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性**系主任**对于码**学号**的传递函数依赖，所以**学生**表的设计，不符合3NF的要求。

为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：

1. 选课（学号，课名，分数）
2. 学生（学号，姓名，系名）
3. 系（系名，系主任）

新的数据表如下：

![img](https://pic1.zhimg.com/80/8bca802bcff92a8945bf808d18d7ec62_hd.jpg)

该拆分带来的收益有：

1. 删除某个系中所有的学生记录
   该系的信息不会丢失。——有改进
2. 插入一个尚无学生的新系的信息。
   因为系表与学生表目前是独立的两张表，所以不影响。——有改进
3. 数据冗余更加少了。——有改进

由此可见，符合3NF要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常只做到2NF或者1NF。

### BCNF范式

由一个具体的关系型数据表设计来引入BCNF范式，假设：

1. 某公司有若干个仓库
2. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作
3. 一个仓库中可以存放多种物品，一种物品也可以存放在不同仓库中，每种物品在每个仓库中都有对应的数量。

有上述介绍，我们可以得到该表的函数依赖集：

1. 仓库名 -> 管理员
2. 管理员 -> 仓库名
3. (仓库名，物品名) -> 数量

因此，该表的minimal key有**两个**(管理员，物品名)和(仓库名，物品名)，从而确定了该表的主属性为**(管理员，仓库名，物品名)**，非主属性为**数量**。该表设计是符合3NF的

![img](https://pic4.zhimg.com/80/68d080d437732aad8cfe451b427849d6_hd.jpg)

然而，尽管该表符合了3NF的设计规则，仍然存在以下问题：

1. 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
2. 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。
3. 如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。

从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。

造成此问题的原因：存在着**主属性**对于**码**的**部分函数依赖**与**传递函数依赖**。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。）

解决办法就是要在 3NF 的基础上消除**主属性**对于码的**部分与传递函数依赖**：

1. 仓库（仓库名，管理员）
2. 库存（仓库名，物品名，数量）

## 事务(Transaction)

一个数据库事务通常包含对数据库进行读或写的一个**操作序列**。它的存在包含有以下两个目的：

* 为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
* 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。

### 特性

并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。

* 原子性(Atomicity)：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
* 一致性(Consistency)：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
* 隔离性(Isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
* 持久性(Durability)：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。

### 举例

用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：

1、从A账号中把余额读出来（500）。
2、对A账号做减法操作（500-100）。
3、把结果写回A账号中（400）。
4、从B账号中把余额读出来（500）。
5、对B账号做加法操作（500+100）。
6、把结果写回B账号中（600）。

####  原子性：

保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。

#### 一致性

在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。

#### 隔离性

在A向B转账的整个过程中，只要事务还没有**提交（commit）**，查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。
如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。

#### 持久性

一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！